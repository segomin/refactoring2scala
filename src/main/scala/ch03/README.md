# CHAPTER 03 코드에서 나는 악취

> 냄새 나면 당장 갈아라. - 켄트 벡 할머니의 육아 원칙
>
> 우리 경험에 따르면 숙련된 사람의 직관만큼 정확한 기준은 없다. 종료 기준보다는 리팩터링하면 해결할 수 있는 문제의 징후를 제시하겠다.
> 인스턴스 변수는 몇 개가 적당한지, 메서드가 몇 줄 을 넘어가면 안 좋은지 등은 각자 경험을 통해 감을 키워야 한다

예전에 봤던 블로그 [좋은 코드를 많이 봐야 한다](https://blog.seulgi.kim/2018/02/you-should-read-good-code.html) 가 생각났다.

결국에 좋은 코드를 만들기 위해서는 좋은 코드를 많이 보는 연습이 필요하다는 말이다.

결국에 좋은 코드라는 목표점을 그릴 줄 알아야 냄새를 감지 하기에도 좋고, 궁극적으로 바람직한 리펙토링 기술을 사용할 수 있으리라 본다.

## 3.1 기이한 이름 (Mysterious Name)

> 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다.
> 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

무엇을 하는가를 설명하는 주석은 좋지 않고, 이런 주석은 리펙토링으로 주석을 지워야 한다고 배웠다.
필요한 주석이란, 왜 이런 코드를 작성했는지를 표현하면 된다고.

잘못된 말은 아니겠지만, 요즘은 무엇에 대한 설명이라도 코드를 읽는데 도움이 된다면 작성하는 편이다.
이런 부분에서 냄새가 나는 지는 세심히 살펴 봐야겠다.

## 3.2 중복 코드 (Duplicated Code)

> 코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.

중복코드를 최대한 피하려고 하지만, 잘 안될때가 있다.

## 3.3 긴 함수 (Long Function)

> 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다.
> 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
> 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름 이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.
>
> 함수 이름은 동작 방식이 아닌 `의도`가 드러나게 짓는다.
>
> 추출할 코드 덩어리는 어떻게 찾아낼까? 한 가지 좋은 방법은 주석을 참고하는 것이다.

좋은 말이지만 여전히 이름을 짓는건 어려운 작업이다. 요즘엔 AI 의 도움을 종종 받고 있지만, 이름을 잘 짓는 것도 좋은 코드를 많이 보는게 도움이 될꺼라 생각한다.
주석이 없는 경우 코드에 주석을 달거나, 코드를 말로 설명 중에 함수를 추출하는 포이트를 찾기도 한다. 이런 작업은 페어로 설명할 때 더 잘 나오는 것 같다.

## 3.4 긴 매개변수 목록 (Long Parameter List)

매개변수를 묶을 수 있는 방법이 있다면 묶어서 전달하는 것이 좋다.
단순히 매개변수를 묶기 위해 클래스를 만들기는 선뜻 손이 안간다.
Duck Typing 을 지원하는 Typescript 와 같은 경우와, Java 나 Scala 같은 경우는 서로 클래스화 하는 수준이 달라질듯 싶다.

## 3.5 전역 데이터 (Global Data)

> 전역 데이터는 이를 함부로 사용한 프로그래머들에게 벌을 주는 지옥 4층에 사는 악마들이 만들었다는 말이 돌 정도였다.
> 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.
> 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.

꼬꼬마 시절에 Global 을 좋아라 했고, 책에서 쓰지 말라 해서 안쓰다가, 읽기 전용으로의 사용은 필요에 따라 잘 사용하고 있다.
특히 Domain 객체 내에서 (de)serialize 하는 과정이 필요한 경우들이 있었고, 이를 주입 받아서 사용하려면 번거로운 주입이 필요했다.
이런 경우에는 전역으로 사용하는 것이 편리했고, 테스트 작성시 적당히 설정해주면 나쁘지 않다고 생각한다.
난 이것을 현실주의 프로그래밍이라고 생각한다.

## 3.6 가변 데이터 (Mutable Data)

> 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값 이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
> API를 만들 때는 질의 함수와 변경 함수 분리하기를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.

Java 에서 리스트는 수도없이 사용하지만, 불변으로 만들어서 까지는 사용해 보지 않았다.
다만 Rich Domain Model 에 대해 알게 되면서 가급적 모델에서 변경 메서드를 제공하려 하고 있다.
이 편이 확실히 더 나은듯 하다.

## 3.7 뒤엉킨 변경 (Divergent Change)

> 뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타난다.
> 우리는 이렇게 분리하는 일이 중요함을 예전부터 알고 있었지만 나이를 먹어 두 뇌 회전이 느려지는 요즘에는 더더욱 중요한 일이 돼버렸다.

귀에 딱지가 붙을 정도로 많이 들었지만, 그럼에도 불구하고 어느 순간 뒤엉킨 변경을 하는 경우가 많은것 같다.
자주 마주치는 냄새 이므로 좀 더 신경 쓴다면 실력도 빨리 늘지 않을까 싶다.

## 3.8 산탄총 수술 (Shotgun Surgery)

> 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.
> 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.

뒤엉킨 변경과 다르다고는 하지만 어렵지 않게 주변에서 찾아볼 수 있다.
이 경우 묶은 다음 다시 분리하는 방법을 사용하라고 한다.

## 3.9 기능 편애 (Feature Envy)

> 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다.
> 이 함수가 데이터와 가까 이 있고 싶어 한다는 의중이 뚜렷이 드러나므로 소원대로 데이터 근처로 옮겨주면 된다.

함수를 여러 조각으로 나누어 각각 적합한 모듏로 옮기거나, 디자인 패턴(전략(Strategy), 방문자(Visitor)) 을 사용해서 함께 변경할 대상을 한데 모으는 방법이 있다

## 3.10 데이터 뭉치 (Data Clumps)

> 데이터 항목들은 어린아이 같은 면이 있다. 서로 어울려 노는 걸 좋아한다.
> 그래서 데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다.
>
> 가장 먼저 필드 형태의 데이터 뭉치를 찾아서 클래스 추출하기로 하나의 객체로 묶는다.

VO 도 잘 활용하면 코드가 많이 깔끔해지는 것 같다.
VO 의 경우 Entity 에서 사용하면서 DTO 에서도 동일한 VO 를 재사용 해도 괜찮을듯 싶다.
다만 Jpa 에서 Embeddable 로 사용하는 VO 를 DTO 에서도 사용하면 두가지 성격의 Annotaion 이 섞이는게 조금 찜찜하기는 하다.

## 3.11 기본형 집착 (Primitive Obsession)

> 기본형을 객체로 바꾸기를 적용하면 기본형만이 거주하는 구석기 동굴을 의미 있는 자료형들이 사는 최신 온돌식 코드로 탈바꿈시킬 수 있다.
> 자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치다.

좋은건 알겠는데 아직까지 하나짜리 필드를 클래스로 감싸는건 잘 안하게 된다.

## 3.12 반복되는 switch문 (Repeated Switches)

> 중복된 Switch문이 문제가 되는 이유는 조건을 하나 추가할 때마다 다른 switch문들도 모 두 찾아서 함께 수정해야 하기 때문이다.

## 3.13 반복문

> 지금은 일급 함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.

Java 에서 단순 map 이나 filter 를 사용하려고 stream을 써보면 다른 언어에 비해 많이 불편하다.

이럴 때 단순 map 이나 filter, flatMap 등은 Util 클래스로 사용하기도 하고, [Underscore-java](https://javadev.github.io/underscore-java/) 같은
라이브러리를 사용하기도 한다.
Lombok 의 [@ExtensionMethod](https://projectlombok.org/features/experimental/ExtensionMethod) 를 함께 사용하면 조금은 Javascript 나
Kotlin 비스므리 하게 사용 할 수 있다. (나도 Kotlin 으로 일하고 싶다...)

## 3.14 성의 없는 요소 (Lazy Element)

...

## 3.15 추측성 일반화 (Speculative Generality)

> 이 냄새는 '나중에 필요할 거야라는 생각으로 당장은 필요 없는 모든 종류의 후킹포 인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다.
>
> 미래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만, 그렇지 않는다면 쓸데없는 낭비일 뿐이다. 당장 걸리적거리는 코드는 눈앞에서 치워버리자.

## 3.16 임시 필드 (Temporary Field)

> 간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는게 보통이라,
> 이렇게 임시 필드를 갖도록 작성 하면 코드를 이해하기 어렵다.

`클래스 추출하기` + `함수 옮기기` 로 임시필드들과 관련있는 코드를 몰아넣는다.

## 3.17 메시지 체인 (Message Chains)

> 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

`디미터의 법칙(Law of Demeter)` 을 따르면서, 중개자를 만들어서 체인의 존재를 감추는 방법이 있다.

## 3.18 중개자 (Middle Man)

지나친 중개자는 `중개자 제거하기` 를 활용한다

## 3.19 내부자 거래 (Insider Trading)

모듈 사이의 데이터 거래를 줄이고 투명하게 처리하도록 한다.
다시말해 응집도를 높히고, 결합도를 낮추는 방향으로 리펙토링한다.

## 3.20 거대한 클래스 (Large Class)

> 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.
> 같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택하면 된다.
> 한 클래스 안에서 접두어나 접미어가 같 은 필드들이 함께 추출할 후보들이다.
> 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다.

클래스를 분리해서 중복을 제거한다.
`클래스 추출하기`, `슈퍼클래스 추출하기`, `타입 코드를 서브클래스로 바꾸기`

## 3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)

> 클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다.
> 단, 교체하려면 인터페이스가 같아야 한다.

메서드의 시그니처를 일치시키고, 인터페이스가 같아질 때까지 필요한 동작을 클래스 안으로 밀어 넣는다...(?)

## 3.22 데이터 클래스 (Data Class)

> 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다.
> 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다.
> 이런 경우라면 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.

데이터 클래스를 사용하면, 데이터를 캡슐화하고, 데이터를 다루는 메소드를 함께 묶어서 관리할 수 있다.

> 불변 필드는 굳이 캡슐화할 필요가 없 고, 불변 데이터로부터 나오는 정보는 게터를 통하지 않고 그냥 필드 자체를 공개해도 된다.

불변 객체에 대해 생각해 보면, VO 의 경우 불변으로 만들어서 사용하는 경우가 많다.
Java 에서 불변 객체의 Primitive 필드를 사용하는 경우에도 습관적으로 getter 를 사용하곤 하는데,
(나를 포함) 왜 다들 getter 를 사용하는지 궁금하다.
(머리로는 불변 field 를 public 으로 해도 될 듯 한데, 그렇게는 잘 안하게 된다.)

## 3.23 상속 포기

> 일부 동작을 재활용하기 위한 목적으로 상속을 활용하기도 하는데, 실무 관점에서 아주 유용한 방식이다.
> 솔직히 냄새를 풍기지만, 보통은 참을 만한 경우 가 많다.

초기 OOP 언어 사용시 빈번하게 사용했던 방법이다.

> 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다.
> 구현을 따르지 않는 것은 이해할 수 있지만 인터페이스를 따르지 않는다는 것은 상당히 무례한 태도다.

`리스코프 치환 원칙(Liskov Substitution Principle)` 을 기준으로 생각하면 도움이 되는것 같다.

## 3.24 주석

> 주석을 달면 안 된다고 말하려는 건 아니니 걱정하지 말자. 주석은 악취가 아닌 향기를 입힌다.
> 문제는 주석을 탈취제처럼 사용하는 데 있다. 주석이 장황하게 달린 원인이 코드를 잘못 작성 했기 때문인 경우가 의외로 많다.
>
> 코드 블록이 하는 일에 주석을 남기고 싶다면 `함수 추출하기`를
>
> 여전히 설명이 필요하다면 `함수 선언 바꾸기`로
>
> 선행조건을 명시하고 싶다면 `어서션 추가하기`가 대기하고 있다

요즘은 주석을 좀 남기는 편이다. 주석을 남기면서 생각이 정리되는 경우도 있고,
다른 사람(미래의 나)에게 도움이 된다고 생각하기 때문이다.

나중에 주석에 의해 리펙터링 필요성을 느끼게 되는 계기가 될지도 모르겠다.
주석 달기는 논쟁이 많은 주제이고, 어느정도 기준을 갖는건 좋지만, 원칙으로 정하기는 어렵다는 생각이다.

[프로그래머의 뇌](https://product.kyobobook.co.kr/detail/S000001952236) 에서도 주석에 대한 논의가 있는데,
결론적으로 `프로그래머는 주석을 읽는다`는 것이다. 이는 유용한 주석은 코드를 분석하는데 도움을 준다는 뜻이다.

> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.

때로는 주석은 남긴 후 리펙터링 하는 것도 생각해 볼 만 한듯

> 뭘 할지 모를 때라면 주석을 달아두면 좋다.

여러번 TDD 를 시도해 봤지만, 좀처럼 실무에서 성공하지는 못했다. 이럴때 주석으로 시작해 보는게 도움이 될지도...