- [8.1 함수 옮기기](#81-함수-옮기기)
- [8.2 필드 옮기기](#82-필드-옮기기)
- [8.3 문장을 함수로 옮기기](#83-문장을-함수로-옮기기)
- [8.4 문장을 호출한 곳으로 옮기기](#84-문장을-호출한-곳으로-옮기기)
- [8.5 인라인 코드를 함수 호출로 바꾸기](#85-인라인-코드를-함수-호출로-바꾸기)
- [8.6 문장 슬라이드하기](#86-문장-슬라이드하기)

# CHAPTER 08 기능 이동

함수 옮기기, 필드 옮기기, 문장 슬라이드, 문장을 함수로, 혹은 문장을 호출한 곳으로 옮기기 등으로
컨텍스트를 고려하면서 코드를 적합한 곳(클래나 모듈)으로 옮기는 방법을 배운다.

반복문 쪼개기, 반복문을 파이프라인으로 바꾸기 등은 실무에서도 유용하게 많이 사용해 본 리펙터링 기법으로,
코드의 품질을 위해 약간의 성능을 감수하며 얻을 수 있는 효과를 경험할 수 있다.

## 8.1 함수 옮기기

```diff
class Account(daysOverdrawn: Int, accountType: AccountType) {
-  def overdraftCharge: Double = {???}

class AccountType {
+  def overdraftCharge(daysOverdrawn: Int): Double = {???}
```

> [!NOTE]
> 좋은 소프트웨어 설계의 핵심은 모듈화가 얼마나 잘 되어 있느냐를 뜻하는 모듈성<sup>modularity</sup>이다.
>
> 이해도가 높아질수록 소프트웨어 요소들을 더 잘 묶는 새로운 방법을 깨우치게 된다.

_요구사항이 변경되지 않더라도 도메인 이해도에 따른 리펙토링도 필요해 지는듯 하다._

> 모든 함수는 어떤 컨텍스트 안에 존재한다

_함수를 옮길지 말지를 판단할 떄는 그 함수와 데이터, 그리고 주변 컨텍스트들의 관계를 둘러봐야 한다._

* 절차
    * 선택한 함수가 해당 컨텍스트에서 사용중인 모든 프로그램 요소를 살펴보고, 함께 옮겨야 할 게 있는지 고민한다.
    * 선택한 함수가 다형 메서드 인지 확인한다.
    * 선택한 함수를 타깃 컨텍스트로 복사한다.
    * 소스 컨텍스트에서 타킷 함수를 참조하도록 수정한다
    * 소스 함수를 인라인 할지 고민한다.

최상위 함수는 가시성이 가장 높으니 적합한 이름을 신중히 지어주는 게 좋다.

_(성능 보다는 가독성을 우선시 한다: [totalDistance](ch8-1-1.scala) 계산을 두번 하더라도)_

> 함께 옮겨지는 프로그램 요소들의 의존성을 고려해서 최상위로 옮기는게 좋다.

* _클래스에 메소드들 중에 `Utils성 함수들의 경우 클래스 밖으로 빼내는게 좋다` 로 들리기는 하지만,
  딱히 범용적으로 사용되는 로직이 아니라면 나는 우선 클래스 내에 두는 편이다._
* _Utils성 함수도 쌓여가는 동안 관리에 주의하지 않으면 진한 구린내를 경험하게 된다._
* _그리고 왠지 Utils성 함수가 많아지면 객체지향 프로그래밍의 장점을 잘 사용하지 못하고 있다는 느낌도 든다._

## 8.2 필드 옮기기

```diff
class Customer (
    val plan: Plan, 
-    val discountRate: Double
) { 
+    def discountRate: Double = plan.discountRate

class Plan (
+    val discountRate: Double
) {
```

> [!NOTE]
> * 프로그램의 진짜 힘은 데이터 구조에서 나온다.
> * 주어진 문제에 적합한 데이터 구조를 활용하면 동작 코드는 자연스럽게 단순하고 직관적으로 짜여진다.
>
> * 경험과 도메인 주도 설계 같은 기술은 데이터 구조를 설계하는 능력을 개선해준다.
> * 하지만, 그럼에도 초기 설계에서는 실수가 빈번하다.
> * 프로젝트를 진행할수록 문제 도메인과 데이터 구조에 대해 더 많은 것을 배우고
    > 오늘까지는 합리적이로 올바랐던 설계가 다음주에는 잘못된 것으로 판명나곤 한다.

* _설계와 코드를 수정해야 하는 여러 다양한 이유로 인해, 리펙토링이 필요성을 계속 설명한다._
* _여기서도 DDD 를 언급하는 것으로 봐서 확실히 도메인 주도 설계가 중요하다는 것을 알 수 있다._
* _다만, DDD 를 따른다고 할 때 다들 Root Aggregate 에 대한 제약조건을 얼마나 지키는지 궁금하다._
    * 개인적으로는 Root Aggregate 를 지키면서 코딩하지는 못하고 있다.

> [!TIP]
> 함수에 어떤 레코드를 넘길 때마다 또 다른 레코드의 필드도 함게 넘기고 있다면 데이터 위치를 옮겨야 할 것아다.

* _데이터 구조를 개선하는 과정도 필요 하겠지만, 이로 인한 DB 설계를 중간에 변경하는건 쉽지 않다._
* _이로인해 DB 에 영향을 미치는 경우 필드 옮기기는 상황에 따라 많은 제약이 있을 것으로 보인다._

## 8.3 문장을 함수로 옮기기

```diff
def photoDiv(photo: Photo) = List(
  "<div>",
-  s"<p>제목: ${photo.title}</p>",
  emitPhotoData(photo),
  "</div>"
).mkString("\n")

def emitPhotoData(photo: Photo) = List(
+  s"<p>제목: ${photo.title}</p>",
  s"<p>위치: ${photo.location}</p>",
  s"<p>날짜: ${photo.date.toDateString}</p>"
).mkString("\n")
```

> [!NOTE]
> 중복 제거는 코드를 건강하게 관리하는 가장 효과적인 방법 중 하나다.

* 절차
    * 반복 코드가 함수 호출 부분과 떨어져 있다면 문장 슬라이드 하기를 적용
    * 호출자가 둘 이상이면 호출자 중 하나에서 타깃 함수 호출 부분과 그 함수로 옮기려는 문장을 함께 추출하여 새 함수로 만든다.
    * ...

* _호출자 수가 여럿이면 안전한 길을 택한다고 하는데,_
* _왠만하면 최대한 리펙토링 도구를 사용해서 편하게 작업할 듯 싶다._

## 8.4 문장을 호출한 곳으로 옮기기

```diff
def renderPerson(outStream: OutputStream, person: Person): Unit = {
  outStream.write(s"<p>${person.name}</p>\n".getBytes)
  emitPhotoData(outStream, person.photo)
+  outStream.write(s"<p>위치: ${person.photo.location}</p>\n".getBytes)
}

def emitPhotoData(outStream: OutputStream, photo: Photo): Unit = {
  outStream.write(s"<p>제목: ${photo.title}</p>\n".getBytes)
  outStream.write(s"<p>날짜: ${photo.date.toDateString}</p>\n".getBytes)
-  outStream.write(s"<p>위치: ${person.photo.location}</p>\n".getBytes)
}
```

> [!NOTE]
> * **함수는 프로그래머가 쌓아 올리는 추상화의 기본 빌딩 블록이다.**
> * 그런데 추상화라는 것이 그 경계를 항상 올바르게 긋기가 만만치 않다.
> * 코드베이스의 기능 범위가 달라지면 추상화의 경계도 움직이게 된다.

* 절차
    * 단순한 상황이면 이동할 부분을 잘라내어 복사해 넣는다.
    * 복잡한 상황에서는 이동하지 않기 원하는 모든 문장을 함수로 추출한 다음
    * 원래 함수를 인라인 한다
    * 추출된 함수와 동일한 부분을 추출한 함수로 대체한다.
    * (대략 상세부분 생략)

## 8.5 인라인 코드를 함수 호출로 바꾸기

```diff
- var appliesToMass = false
- for (s <- states) {
-   if (s == "MA") appliesToMass = true
- }
+ def appliesToMass = states.contains("MA")
```

> [!NOTE]
> * 함수는 여러 동작을 하나로 묶어준다,
> * 함수의 **이름**의 코드의 **동작** 방식보다는 **목적**을 말해주기 때문에 함수를 활용하면 코드를 이해하기가 쉬워진다.

> [!NOTE]
> * 함수 추출하기와 이번 리펙토링의 차이는 인라인 코드를 대체할 함수가 이미 존재하느냐 여부다.
> * 표준 라이브러리나 플랫폼, 혹은 라이브러리 들이 제공하는 API를 잘 파악하고 있을수록 이 리펙토링의 활용 빈도가 높아질 것이다.

## 8.6 문장 슬라이드하기

```diff
val pricingPlan = retrievePricingPlan()
+ val chargePerUnit = pricingPlan.unit
val order = retrieveOrder()
var charge: Double
- val chargePerUnit = pricingPlan.unit
```

> [!NOTE]
> * 관련된 코드들이 가까이 모여 있다면 이해하기가 더 쉽다.
> * 관련 코드끼리 모으느 작업은 다른 리펙터링의 준비 단계로 자주 행해진다.

> * 현명한 프로그래머들은 되도록 부수효과 없는 코드를 작성하려고 한다.
> * 내가 직접 작성한 코드라면 값을 반환하는 함수는 모두 부수효과가 없다.

* _요구사항에 따라 조회하는 API 에서 로그를 남겨야 한다거나,_
* _읽음 표시가 필요한 로직이 필요한 경우가 있다. 혹은 캐시를 한다거나._
* _이런 경우 부수효과가 꼭 필요하겠지만, 최대한 부수효과 부분을 격리시키는게 좋을듯 하다._

> [!TIP]
> * 큰 슬라이드를 수행하기 어려울 때만 한 문장씩 이동한다.
> * 하지만 지저분한 코드를 정리할 때는 더 작게 슬라이드하는 편이 좋다.