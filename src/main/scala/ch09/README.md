- [9.1 변수 쪼개기](#91-변수-쪼개기)
- [9.2 필드 이름 바꾸기](#92-필드-이름-바꾸기)
- [9.3 파생 변수를 질의 함수로 바꾸기](#93-파생-변수를-질의-함수로-바꾸기)
- [9.4 참조를 값으로 바꾸기](#94-참조를-값으로-바꾸기)
- [9.5 값을 참조로 바꾸기](#95-값을-참조로-바꾸기)
- [9.6 매직 리터럴 바꾸기](#96-매직-리터럴-바꾸기)


# CHAPTER 09 데이터 조직화 

> 하나의 값이 여러 목적으로 사용된다면 혼란과 버그를 낳는다.

_한번은 js 로 되어 있던 레거시를 ts 로 마이그레이션 하면서 고생한 적이 있었다._

_하나의 객체에 필드가 변경되는 경우 뿐만 아니라, 심지어 동일 필드의 type이 변경(Number -> String)되는 경우도 많았다._
 
## 9.1 변수 쪼개기

```diff
- var temp = 2 * (height + width)
- println(temp)
- temp = height + width
- println(temp)
+ val perimeter = 2 * (height + width)
+ println(perimeter)
+ val area = height + width
+ println(area)
```

> 대입이 두 번 이상 이뤄진다면 여러 가지 역 할을 수행한다는 신호다. 
> 역할이 둘 이상인 변수가 있다면 쪼개야 한다. **예외는 없다.**

* 절차 (간소화 함)
  * 처음 대입하는 변수의 이름을 변경한다.
  * 가능하면 이때 불변으로 선언한다
  * 두 번째로 대입하는 변수를 원래 이름으로 다시 선언한다.

_Java 에는 final 키워드로 변수를 불변으로 만드는 경우가 있다._
_하지만 개인적으로 메소드 내에 지역변수는 잘 사용하지 않는 편이다._
_변경을 하겠다는 의미 보다는 메소드는 작게 가져가고 그냥 한번만 할당한다._

_어차피 원시값이 아닌이상 final 이 아무 의미 없이 쓰이는 코드도 있다._

> 함수의 파라미터는 데이터를 전달하는 용도 이다.

_함수의 파라미터를 수정해서 사용하는 경우는 흔히 볼 수 있는데,_

_수정하지 않는게 좋다고는 들었지만 명시적으로 다른 용도여서라는 생각은 못해봤다._

_Scala 에서는 기본적으로 이런 사용이 막혀있던게 인상적이다._

* 파라미터를 재할당 한 변수를 사용하면 값이 동일한 경우에도, 
* 파라미터를 사용하는 코드는 **'입력 값에 기초한'** 이라는 의도를 명확하게 할 수 있다.

## 9.2 필드 이름 바꾸기

```diff
class Organization {
-  val name: String ...
+  val title: String ...
}
```

> 프레드 브룩스(Pcd Broks는 이런 말을 했다. 
> "데이터 테이블 없이 흐름도"<sup>owchar</sup>만 보여줘서는 나는 여전히 혼란스러울 것이다. 
> 하지만 데이터 테이블을 보여준다면 흐름도는 웬만해선 필요조차 없을 것이다. 
> 테이블만으로 명확하기 때문이다."

> 데이터 구조는 무슨 일이 벌어지는지를 이해하는 열쇠다.

> '작은 단계라 함은 각 단계에서 잘못될 일이 적어졌고, 그래서 한 일도 줄었다는 뜻이다. 
> 물론 실수를 저지르지 않는다면 줄어들 일도 없지만, 
> 실수 없이란 내가 아주 예전에 포기한 **판타지일** 뿐이다.

_테스트가 없는 코드를 리펙토링 해야 할 때가 여전히 많이 있다._
_도구를 사용하는 경우 실수가 없을거라 예상하지만, 사실 이런 경우도 종종 실수를 경험하곤 한다._

## 9.3 파생 변수를 질의 함수로 바꾸기

```diff
// javascript
- get discountedTotal() {return this. discountedTotal;}
- set discount (aNumber) {
-   const old = this. _discount;
-   this. _discount = aNumber;
-   this. _discountedTotal += old - aNumber;
+ get discountedTotal() {return this. baseTotal - this. discount;}
+ set discount(aNumber) {this. discount = aNumber;}
```
> [!NOTE]
> * 가변 데이터는 서로 다른 두 코드를 이상한 방식으로 결합하기도 하는데, 
> * 예컨대 한 쪽 코드에서 수정한 값이 연쇄 효과를 일으켜 다른 쪽 코드에 원인을 찾기 어려운 문제를 야기하기도 한다.
> * 그렇다고 가변 데이터를 완전히 배제하기란 현실적으로 불가능할 때가 많지만, 
> * 가변 데이터의 유효 범위를 가능 한 한 좁혀야 한다고 힘주어 주장해본다.
> * 효과가 좋은 방법으로, 값을 쉽게 계산해낼 수 있는 변수들을 모두 제거할 수 있다.

* 중복에는 코드 중복 뿐만 아니라 데이터 중복도 개선해야 한다.

## 9.4 참조를 값으로 바꾸기

```diff
class Product {
-  def applyDiscount(arg: Int): Unit = {
-    _price.amount -= arg
-  }
+  def applyDiscount(arg: Int): Unit = {
+    price = new Money(_price.amount - arg, _price.currency)
+  }
}
```

> [!NOTE]
> * 참조냐 값이냐의 차이는 내부 객체의 속성을 갱신하는 방식에서 가장 극명하게 드러난다. 
> * 참조로 다루는 경우에는 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신하며, 
> * 값으로 다루는 경우에는 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체한다.
> * 필드를 값으로 다룬다면 값 객체<sup>value object</sup>(불변)로 만들 수 있다.

> 값 객체로 만들면 안되는 경우
> * 특정 객체를 여러 객체에서 공유하고자 한다면, 
> * 그래서 공유 객체의 값을 변경했을 때 이를 관련 객체 모두에 알려줘야 한다면 
> * 공유 객체를 참조로 다뤄야 한다.

## 9.5 값을 참조로 바꾸기

```diff
// javascript
- let customer = new Customer (customerData);
+ let customer = customerRepository.get (customerData.id);
```
> [!NOTE]
> * 논리적으로 같은 데이터를 물리적으로 복제해 사용할 때 가장 크게 문제되는 상황은 
> * 그 데이터를 갱신해야 할 때다. 모든 복제본을 찾아서 빠짐없이 갱신해야 하며, 
> * 하나라도 놓치면 데이터 일관성이 깨져버린다. 이런 상황이라면 복제된 데이터들을 모두 참조로 바꿔주는 게 좋다.
> * 값을 참조로 바꾸면 엔티티 하나당 객체도 단 하나만 존재하게 되는데, 
> * 그러면 보통 이런 객체들을 한데 모아놓고 클라이언트들의 접근을 관리해주는 일종의 저장소<sup>repository</sup>가 필요해진다.

_때로는 DB 구조에서도 변경된 데이터를 일괄적으로 찾아서 변경해야 하는 경우들이 있다._
_DB 에서는 이런 참조하는 데이터를 모두 연관관계를 만들기 어려운 상황도 있다._

### 9.6 매직 리터럴 바꾸기
```diff
def potentialEnergy(mass: Double, height: Double): Double = {
-  mass * 9.81 * height
+  mass * STANDARD_GRAVITY * height
}
```

> * 일반적으로는 매직 리터럴<sup>magic literal</sup> 값이 쓰이는 모든 곳을 적절한 이름의 상수로 바꿔주는 방법이 가장 좋ek.
> * 다른 방법으로는 그 상수가 특별한 비교 로직에 주로 쓰이는 경우에 고려해볼 수 있다.
> * `aValue == "M"`을 `aValue = MALE_GENDER` 로 바꾸기보다
> * isMail(aValue) 라는 함수 호출로 바꾸는 쪽을 선호한다. 
> * 상수를 과용하는 모습도 종종 본다. `const ONE = 1` 같은 선언은 의미가 없다.

_스트링을 동일한 대문자 상수로 만드는 경우는 다시한번 생각해봐야 할 것 같다._
